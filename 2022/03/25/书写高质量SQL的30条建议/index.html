

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon_ico.png">
  <link rel="icon" href="/img/favicon_ico.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="分享总结个人的学习路程">
  <meta name="author" content="屠雍">
  <meta name="keywords" content="PCB, 单片机, 物联网, 嵌入式, Java, Linux, Web前端">
  <meta name="description" content="书写高质量SQL的30条建议  前言本文将结合实例demo，阐述30条有关于优化SQL的建议，多数是实际开发中总结出来的，希望对大家有帮助。 1、查询SQL尽量不要使用select *，而是select具体字段。反例子： 1select * from employee;  正例子： 1select id，name from employee;  理由：  只取需要的字段，节省资源、减少网络开销。">
<meta property="og:type" content="article">
<meta property="og:title" content="书写高质量SQL的30条建议">
<meta property="og:url" content="http://example.com/2022/03/25/%E4%B9%A6%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FSQL%E7%9A%8430%E6%9D%A1%E5%BB%BA%E8%AE%AE/index.html">
<meta property="og:site_name" content="小贝比">
<meta property="og:description" content="书写高质量SQL的30条建议  前言本文将结合实例demo，阐述30条有关于优化SQL的建议，多数是实际开发中总结出来的，希望对大家有帮助。 1、查询SQL尽量不要使用select *，而是select具体字段。反例子： 1select * from employee;  正例子： 1select id，name from employee;  理由：  只取需要的字段，节省资源、减少网络开销。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131655264.png">
<meta property="og:image" content="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131655866.png">
<meta property="og:image" content="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131658963.png">
<meta property="og:image" content="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131659920.png">
<meta property="og:image" content="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131700074.png">
<meta property="og:image" content="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131701802.png">
<meta property="og:image" content="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131701318.png">
<meta property="og:image" content="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131702119.png">
<meta property="og:image" content="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131702542.png">
<meta property="og:image" content="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131702087.png">
<meta property="og:image" content="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131702643.png">
<meta property="og:image" content="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131703508.png">
<meta property="og:image" content="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131704014.png">
<meta property="og:image" content="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131705969.png">
<meta property="og:image" content="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131705474.png">
<meta property="og:image" content="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131709846.png">
<meta property="og:image" content="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131709592.png">
<meta property="og:image" content="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131709024.png">
<meta property="article:published_time" content="2022-03-25T13:46:50.945Z">
<meta property="article:modified_time" content="2022-03-25T10:16:56.543Z">
<meta property="article:author" content="屠雍">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131655264.png">
  
  <title>书写高质量SQL的30条建议 - 小贝比</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/atom-one-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>小贝比的个人博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/background7.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="书写高质量SQL的30条建议">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-03-25 21:46" pubdate>
        2022年3月25日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.2k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      29 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">书写高质量SQL的30条建议</h1>
            
            <div class="markdown-body">
              <center><h2>书写高质量SQL的30条建议</h2></center>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文将结合实例demo，阐述30条有关于优化SQL的建议，多数是实际开发中总结出来的，希望对大家有帮助。</p>
<h3 id="1、查询SQL尽量不要使用select-，而是select具体字段。"><a href="#1、查询SQL尽量不要使用select-，而是select具体字段。" class="headerlink" title="1、查询SQL尽量不要使用select *，而是select具体字段。"></a>1、查询SQL尽量不要使用select *，而是select具体字段。</h3><p>反例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employee;<br></code></pre></div></td></tr></table></figure>

<p>正例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id，name <span class="hljs-keyword">from</span> employee;<br></code></pre></div></td></tr></table></figure>

<p>理由：</p>
<ul>
<li>只取需要的字段，节省资源、减少网络开销。</li>
<li>select * 进行查询时，很可能就不会使用到覆盖索引了，就会造成回表查询。</li>
</ul>
<h3 id="2、如果知道查询结果只有一条或者只要最大-最小一条记录，建议用limit-1"><a href="#2、如果知道查询结果只有一条或者只要最大-最小一条记录，建议用limit-1" class="headerlink" title="2、如果知道查询结果只有一条或者只要最大/最小一条记录，建议用limit 1"></a>2、如果知道查询结果只有一条或者只要最大/最小一条记录，建议用limit 1</h3><p>假设现在有employee员工表，要找出一个名字叫 jay 的人.</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `employee` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) NOTNULL,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) DEFAULTNULL,<br>  `age` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) DEFAULTNULL,<br>  `<span class="hljs-type">date</span>` datetime DEFAULTNULL,<br>  `sex` <span class="hljs-type">int</span>(<span class="hljs-number">1</span>) DEFAULTNULL,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></div></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id，name <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;jay&#x27;</span><br></code></pre></div></td></tr></table></figure>

<p>正例</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id，name <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;jay&#x27;</span> limit <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure>

<p>理由：</p>
<ul>
<li>加上limit 1后,只要找到了对应的一条记录,就不会继续向下扫描了,效率将会大大提高。</li>
<li>当然，如果name是唯一索引的话，是不必要加上limit 1了，因为limit的存在主要就是为了防止全表扫描，从而提高性能,如果一个语句本身可以预知不用全表扫描，有没有limit ，性能的差别并不大。</li>
</ul>
<h3 id="3、应尽量避免在where子句中使用or来连接条件"><a href="#3、应尽量避免在where子句中使用or来连接条件" class="headerlink" title="3、应尽量避免在where子句中使用or来连接条件"></a>3、应尽量避免在where子句中使用or来连接条件</h3><p>新建一个user表，它有一个普通索引userId，表结构如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-keyword">user</span>` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) NOTNULL AUTO_INCREMENT,<br>  `userId` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) NOTNULL,<br>  `age` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) NOTNULL,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) NOTNULL,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  KEY `idx_userId` (`userId`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></div></td></tr></table></figure>

<p>假设现在需要查询userId为1或者年龄为18岁的用户，很容易有以下sql</p>
<p>反例:</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userId<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">or</span> age<span class="hljs-operator">=</span><span class="hljs-number">18</span><br></code></pre></div></td></tr></table></figure>

<p>正例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>使用 <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userId<span class="hljs-operator">=</span><span class="hljs-number">1</span><br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age<span class="hljs-operator">=</span><span class="hljs-number">18</span><br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>或者分开两条<span class="hljs-keyword">sql</span>写：<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userId<span class="hljs-operator">=</span><span class="hljs-number">1</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age<span class="hljs-operator">=</span><span class="hljs-number">18</span><br></code></pre></div></td></tr></table></figure>

<p>理由：</p>
<ul>
<li>使用or可能会使索引失效，从而全表扫描。</li>
</ul>
<blockquote>
<p>对于or+没有索引的age这种情况，假设它走了userId的索引，但是走到age查询条件时，它还得全表扫描，也就是需要三步过程：全表扫描+索引扫描+合并 如果它一开始就走全表扫描，直接一遍扫描就完事。mysql是有优化器的，处于效率与成本考虑，遇到or条件，索引可能失效，看起来也合情合理。</p>
</blockquote>
<h3 id="4、优化limit分页"><a href="#4、优化limit分页" class="headerlink" title="4、优化limit分页"></a>4、优化limit分页</h3><p>我们日常做分页需求时，一般会用 limit 实现，但是当偏移量特别大的时候，查询效率就变得低下。</p>
<p>反例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id，name，age <span class="hljs-keyword">from</span> employee limit <span class="hljs-number">10000</span>，<span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure>

<p>正例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>方案一 ：返回上次查询的最大记录(偏移量)<br><span class="hljs-keyword">select</span> id，name <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">10000</span> limit <span class="hljs-number">10</span><br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>方案二：orderby <span class="hljs-operator">+</span> 索引<br><span class="hljs-keyword">select</span> id，name <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">10000</span>，<span class="hljs-number">10</span><br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>方案三：在业务允许的情况下限制页数：<br></code></pre></div></td></tr></table></figure>

<p>理由：</p>
<ul>
<li>当偏移量最大的时候，查询效率就会越低，因为Mysql并非是跳过偏移量直接去取后面的数据，而是先把偏移量+要取的条数，然后再把前面偏移量这一段的数据抛弃掉再返回的。</li>
<li>如果使用优化方案一，返回上次最大查询记录（偏移量），这样可以跳过偏移量，效率提升不少。</li>
<li>方案二使用order by+索引，也是可以提高查询效率的。</li>
<li>方案三的话，建议跟业务讨论，有没有必要查这么后的分页啦。因为绝大多数用户都不会往后翻太多页。</li>
</ul>
<h3 id="5、优化你的like语句"><a href="#5、优化你的like语句" class="headerlink" title="5、优化你的like语句"></a>5、优化你的like语句</h3><p>日常开发中，如果用到模糊关键字查询，很容易想到like，但是like很可能让你的索引失效。</p>
<p>反例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> userId，name <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userId <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%123&#x27;</span>;<br></code></pre></div></td></tr></table></figure>

<p>正例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> userId，name <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userId <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;123%&#x27;</span>;<br></code></pre></div></td></tr></table></figure>

<p>理由：</p>
<ul>
<li>把%放前面，并不走索引，如下：</li>
</ul>
<p><img src="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131655264.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<ul>
<li>把 % 放关键字后面，还是会走索引的。如下：</li>
</ul>
<p><img src="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131655866.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<h3 id="6、使用where条件限定要查询的数据，避免返回多余的行"><a href="#6、使用where条件限定要查询的数据，避免返回多余的行" class="headerlink" title="6、使用where条件限定要查询的数据，避免返回多余的行"></a>6、使用where条件限定要查询的数据，避免返回多余的行</h3><p>假设业务场景是这样：查询某个用户是否是会员。曾经看过老的实现代码是这样。。。</p>
<p>反例：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Long&gt; userIds = sqlMap.queryList(<span class="hljs-string">&quot;select userId from user where isVip=1&quot;</span>);<br><span class="hljs-keyword">boolean</span> isVip = userIds.contains(userId);<br></code></pre></div></td></tr></table></figure>

<p>正例：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Long userId = sqlMap.queryObject(<span class="hljs-string">&quot;select userId from user where userId=&#x27;userId&#x27; and isVip=&#x27;1&#x27;&quot;</span>)<br><span class="hljs-keyword">boolean</span> isVip = userId != <span class="hljs-keyword">null</span>;<br></code></pre></div></td></tr></table></figure>

<p>理由：</p>
<ul>
<li>需要什么数据，就去查什么数据，避免返回不必要的数据，节省开销。</li>
</ul>
<h3 id="7、尽量避免在索引列上使用mysql的内置函数"><a href="#7、尽量避免在索引列上使用mysql的内置函数" class="headerlink" title="7、尽量避免在索引列上使用mysql的内置函数"></a>7、尽量避免在索引列上使用mysql的内置函数</h3><p>业务需求：查询最近七天内登陆过的用户(假设loginTime加了索引)</p>
<p>反例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> userId, loginTime <span class="hljs-keyword">from</span> loginuser <span class="hljs-keyword">where</span> Date_ADD(loginTime, <span class="hljs-type">Interval</span> <span class="hljs-number">7</span> <span class="hljs-keyword">DAY</span>) <span class="hljs-operator">&gt;=</span> now();<br></code></pre></div></td></tr></table></figure>

<p>正例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> userId, loginTime <span class="hljs-keyword">from</span> loginuser <span class="hljs-keyword">where</span> loginTime <span class="hljs-operator">&gt;=</span> Date_ADD(NOW(), <span class="hljs-type">INTERVAL</span> <span class="hljs-operator">-</span> <span class="hljs-number">7</span> <span class="hljs-keyword">DAY</span>);<br></code></pre></div></td></tr></table></figure>

<p>理由：</p>
<ul>
<li>索引列上使用mysql的内置函数，索引失效</li>
</ul>
<p><img src="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131658963.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<ul>
<li><p>如果索引列不加内置函数，索引还是会走的。</p>
<p><img src="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131659920.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
</li>
</ul>
<h3 id="8、应尽量避免在-where-子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫"><a href="#8、应尽量避免在-where-子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫" class="headerlink" title="8、应尽量避免在 where 子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫"></a>8、应尽量避免在 where 子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫</h3><p>反例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age <span class="hljs-operator">-</span> <span class="hljs-number">1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>；<br></code></pre></div></td></tr></table></figure>

<p>正例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">11</span>；<br></code></pre></div></td></tr></table></figure>

<p>理由：</p>
<ul>
<li>虽然age加了索引，但是因为对它进行运算，索引直接迷路了。。。</li>
</ul>
<p><img src="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131700074.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<h3 id="9、Inner-join-、left-join、right-join，优先使用Inner-join，如果是left-join，左边表结果尽量小"><a href="#9、Inner-join-、left-join、right-join，优先使用Inner-join，如果是left-join，左边表结果尽量小" class="headerlink" title="9、Inner join 、left join、right join，优先使用Inner join，如果是left join，左边表结果尽量小"></a>9、Inner join 、left join、right join，优先使用Inner join，如果是left join，左边表结果尽量小</h3><blockquote>
<ul>
<li>Inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集</li>
<li>left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。</li>
<li>right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。</li>
</ul>
</blockquote>
<p>都满足SQL需求的前提下，推荐优先使用Inner join（内连接），如果要使用left join，左边表数据结果尽量小，如果有条件的尽量放到左边处理。</p>
<p>反例:</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tab1 t1 <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> tab2 t2 <span class="hljs-keyword">on</span> t1.size <span class="hljs-operator">=</span> t2.size <span class="hljs-keyword">where</span> t1.id <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span>;<br></code></pre></div></td></tr></table></figure>

<p>正例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tab1 <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">2</span>) t1 <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> tab2 t2 <span class="hljs-keyword">on</span> t1.size <span class="hljs-operator">=</span> t2.size;<br></code></pre></div></td></tr></table></figure>

<p>理由：</p>
<ul>
<li>如果inner join是等值连接，或许返回的行数比较少，所以性能相对会好一点。</li>
<li>同理，使用了左连接，左边表数据结果尽量小，条件尽量放到左边处理，意味着返回的行数可能比较少。</li>
</ul>
<h3 id="10、应尽量避免在-where-子句中使用-或-lt-gt-操作符，否则将引擎放弃使用索引而进行全表扫描。"><a href="#10、应尽量避免在-where-子句中使用-或-lt-gt-操作符，否则将引擎放弃使用索引而进行全表扫描。" class="headerlink" title="10、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。"></a>10、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</h3><p>反例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> age, name <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-number">18</span>;<br></code></pre></div></td></tr></table></figure>

<p>正例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>可以考虑分开两条<span class="hljs-keyword">sql</span>写<br><span class="hljs-keyword">select</span> age, name <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">18</span>;<br><span class="hljs-keyword">select</span> age, name <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">18</span>;<br></code></pre></div></td></tr></table></figure>

<p>理由：</p>
<ul>
<li>使用!=和&lt;&gt;很可能会让索引失效</li>
</ul>
<p><img src="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131701802.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<h3 id="11、使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。"><a href="#11、使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。" class="headerlink" title="11、使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。"></a>11、使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。</h3><p>表结构：（有一个联合索引idx_userid_age，userId在前，age在后）</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-keyword">user</span>` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `userId` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `age` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  KEY `idx_userid_age` (`userId`,`age`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">2</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br></code></pre></div></td></tr></table></figure>

<p>反例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br></code></pre></div></td></tr></table></figure>

<p><img src="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131701318.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p>正例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>符合最左匹配原则<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid<span class="hljs-operator">=</span><span class="hljs-number">10</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">=</span><span class="hljs-number">10</span>；<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>符合最左匹配原则<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid<span class="hljs-operator">=</span><span class="hljs-number">10</span>;<br></code></pre></div></td></tr></table></figure>

<p><img src="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131702119.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p><img src="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131702542.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p>理由：</p>
<ul>
<li>当我们创建一个联合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。</li>
<li>联合索引不满足最左原则，索引一般会失效，但是这个还跟Mysql优化器有关的。</li>
</ul>
<h3 id="12、对查询进行优化，应考虑在-where-及-order-by-涉及的列上建立索引，尽量避免全表扫描。"><a href="#12、对查询进行优化，应考虑在-where-及-order-by-涉及的列上建立索引，尽量避免全表扫描。" class="headerlink" title="12、对查询进行优化，应考虑在 where 及 order by 涉及的列上建立索引，尽量避免全表扫描。"></a>12、对查询进行优化，应考虑在 where 及 order by 涉及的列上建立索引，尽量避免全表扫描。</h3><p>反例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> address <span class="hljs-operator">=</span><span class="hljs-string">&#x27;深圳&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age;<br></code></pre></div></td></tr></table></figure>

<p><img src="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131702087.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p>正例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">添加索引<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">add</span> index idx_address_age (address, age)<br></code></pre></div></td></tr></table></figure>

<p><img src="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131702643.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<h3 id="13、如果插入数据过多，考虑批量插入。"><a href="#13、如果插入数据过多，考虑批量插入。" class="headerlink" title="13、如果插入数据过多，考虑批量插入。"></a>13、如果插入数据过多，考虑批量插入。</h3><p>反例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">User</span> u : list)&#123;<br> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>(name,age) <span class="hljs-keyword">values</span>(#name#, #age#)   <br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>正例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>一次<span class="hljs-number">500</span>批量插入，分批进行<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span>(name, age) <span class="hljs-keyword">values</span><br><span class="hljs-operator">&lt;</span>foreach collection<span class="hljs-operator">=</span>&quot;list&quot; item<span class="hljs-operator">=</span>&quot;item&quot; index<span class="hljs-operator">=</span>&quot;index&quot; separator<span class="hljs-operator">=</span>&quot;,&quot;<span class="hljs-operator">&gt;</span><br>    (#&#123;item.name&#125;, #&#123;item.age&#125;)<br><span class="hljs-operator">&lt;</span><span class="hljs-operator">/</span>foreach<span class="hljs-operator">&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>理由：</p>
<ul>
<li>批量插入性能好，更加省时间</li>
</ul>
<blockquote>
<p>打个比喻:假如你需要搬一万块砖到楼顶,你有一个电梯,电梯一次可以放适量的砖（最多放500）,你可以选择一次运送一块砖,也可以一次运送500,你觉得哪个时间消耗大?</p>
</blockquote>
<h3 id="14、在适当的时候，使用覆盖索引。"><a href="#14、在适当的时候，使用覆盖索引。" class="headerlink" title="14、在适当的时候，使用覆盖索引。"></a>14、在适当的时候，使用覆盖索引。</h3><p>覆盖索引能够使得你的SQL语句不需要回表，仅仅访问索引就能够得到所有需要的数据，大大提高了查询效率。</p>
<p>反例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-keyword">like</span> 模糊查询，不走索引了<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%123%&#x27;</span><br></code></pre></div></td></tr></table></figure>

<p><img src="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131703508.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p>正例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>id为主键，那么为普通索引，即覆盖索引登场了。<br><span class="hljs-keyword">select</span> id, name <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%123%&#x27;</span>;<br></code></pre></div></td></tr></table></figure>

<p><img src="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131704014.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<h3 id="15、慎用distinct关键字"><a href="#15、慎用distinct关键字" class="headerlink" title="15、慎用distinct关键字"></a>15、慎用distinct关键字</h3><p>distinct 关键字一般用来过滤重复记录，以返回不重复的记录。在查询一个字段或者很少字段的情况下使用时，给查询带来优化效果。但是在字段很多的时候使用，却会大大降低查询效率。</p>
<p>反例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span>  <span class="hljs-keyword">user</span>;<br></code></pre></div></td></tr></table></figure>

<p>正例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">DISTINCT</span> name <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>;<br></code></pre></div></td></tr></table></figure>

<p>理由：</p>
<ul>
<li>带distinct的语句cpu时间和占用时间都高于不带distinct的语句。因为当查询很多字段时，如果使用distinct，数据库引擎就会对数据进行比较，过滤掉重复数据，然而这个比较，过滤的过程会占用系统资源，cpu时间。</li>
</ul>
<h3 id="16、删除冗余和重复索引"><a href="#16、删除冗余和重复索引" class="headerlink" title="16、删除冗余和重复索引"></a>16、删除冗余和重复索引</h3><p>反例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">KEY `idx_userId` (`userId`)<br>KEY `idx_userId_age` (`userId`,`age`)<br></code></pre></div></td></tr></table></figure>

<p>正例:</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>删除userId索引，因为组合索引（A，B）相当于创建了（A）和（A，B）索引<br>  KEY `idx_userId_age` (`userId`,`age`)<br></code></pre></div></td></tr></table></figure>

<p>理由：</p>
<ul>
<li>重复的索引需要维护，并且优化器在优化查询的时候也需要逐个地进行考虑，这会影响性能的。</li>
</ul>
<h3 id="17、如果数据量较大，优化你的修改-删除语句。"><a href="#17、如果数据量较大，优化你的修改-删除语句。" class="headerlink" title="17、如果数据量较大，优化你的修改/删除语句。"></a>17、如果数据量较大，优化你的修改/删除语句。</h3><p>避免同时修改或删除过多数据，因为会造成cpu利用率过高，从而影响别人对数据库的访问。</p>
<p>反例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>一次删除<span class="hljs-number">10</span>万或者<span class="hljs-number">100</span>万<span class="hljs-operator">+</span>？<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">100000</span>;<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>或者采用单一循环操作，效率低，时间漫长<br><span class="hljs-keyword">for</span>（<span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span> ：list）&#123;<br>   <span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>；<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>正例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>分批进行删除,如每次<span class="hljs-number">500</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">&lt;</span><span class="hljs-number">500</span><br><span class="hljs-keyword">delete</span> product <span class="hljs-keyword">where</span> id<span class="hljs-operator">&gt;=</span><span class="hljs-number">500</span> <span class="hljs-keyword">and</span> id<span class="hljs-operator">&lt;</span><span class="hljs-number">1000</span>；<br></code></pre></div></td></tr></table></figure>

<p>理由：</p>
<ul>
<li>一次性删除太多数据，可能会有lock wait timeout exceed的错误，所以建议分批操作。</li>
</ul>
<h3 id="18、where子句中考虑使用默认值代替null。"><a href="#18、where子句中考虑使用默认值代替null。" class="headerlink" title="18、where子句中考虑使用默认值代替null。"></a>18、where子句中考虑使用默认值代替null。</h3><p>反例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>;<br></code></pre></div></td></tr></table></figure>

<p><img src="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131705969.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p>正例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>设置<span class="hljs-number">0</span>为默认值<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age<span class="hljs-operator">&gt;</span><span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure>

<p><img src="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131705474.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p>理由：</p>
<ul>
<li>并不是说使用了is null 或者 is not null 就会不走索引了，这个跟mysql版本以及查询成本都有关。</li>
</ul>
<blockquote>
<p>如果mysql优化器发现，走索引比不走索引成本还要高，肯定会放弃索引，这些条件<code>！=，&gt;is null，is not null</code>经常被认为让索引失效，其实是因为一般情况下，查询的成本高，优化器自动放弃的。</p>
</blockquote>
<ul>
<li>如果把null值，换成默认值，很多时候让走索引成为可能，同时，表达意思会相对清晰一点。</li>
</ul>
<h3 id="19、不要有超过5个以上的表连接"><a href="#19、不要有超过5个以上的表连接" class="headerlink" title="19、不要有超过5个以上的表连接"></a>19、不要有超过5个以上的表连接</h3><ul>
<li>连表越多，编译的时间和开销也就越大。</li>
<li>把连接表拆开成较小的几个执行，可读性更高。</li>
<li>如果一定需要连接很多表才能得到数据，那么意味着糟糕的设计了。</li>
</ul>
<h3 id="20、exist-amp-in的合理利用"><a href="#20、exist-amp-in的合理利用" class="headerlink" title="20、exist &amp; in的合理利用"></a>20、exist &amp; in的合理利用</h3><p>假设表A表示某企业的员工表，表B表示部门表，查询所有部门的所有员工，很容易有以下SQL:</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> deptId <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> deptId <span class="hljs-keyword">from</span> B);<br></code></pre></div></td></tr></table></figure>

<p>这样写等价于：</p>
<blockquote>
<p>先查询部门表B</p>
<p>select deptId from B</p>
<p>再由部门deptId，查询A的员工</p>
<p>select * from A where A.deptId = B.deptId</p>
</blockquote>
<p>可以抽象成这样的一个循环：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">List<span class="hljs-operator">&lt;&gt;</span> resultSet ;<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i <span class="hljs-operator">&lt;</span> B.length; i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>) &#123;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j <span class="hljs-operator">&lt;</span> A.length; j<span class="hljs-operator">+</span><span class="hljs-operator">+</span>) &#123;<br>       if(A[i].id <span class="hljs-operator">=</span><span class="hljs-operator">=</span> B[j].id) &#123;<br>          resultSet.add(A[i]);<br>          break;<br>       &#125;<br>    &#125;<br> &#125;<br></code></pre></div></td></tr></table></figure>

<p>显然，除了使用in，我们也可以用exists实现一样的查询功能，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> B <span class="hljs-keyword">where</span> A.deptId <span class="hljs-operator">=</span> B.deptId);<br></code></pre></div></td></tr></table></figure>

<p>因为exists查询的理解就是，先执行主查询，获得数据后，再放到子查询中做条件验证，根据验证结果（true或者false），来决定主查询的数据结果是否得意保留。</p>
<p>那么，这样写就等价于：</p>
<blockquote>
<p>select * from A,先从A表做循环</p>
<p>select * from B where A.deptId = B.deptId,再从B表做循环.</p>
</blockquote>
<p>同理，可以抽象成这样一个循环：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">List<span class="hljs-operator">&lt;&gt;</span> resultSet ;<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i <span class="hljs-operator">&lt;</span> A.length;i<span class="hljs-operator">+</span><span class="hljs-operator">+</span>) &#123;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j <span class="hljs-operator">&lt;</span> B.length; j<span class="hljs-operator">+</span><span class="hljs-operator">+</span>) &#123;<br>       if(A[i].deptId <span class="hljs-operator">=</span><span class="hljs-operator">=</span> B[j].deptId) &#123;<br>          resultSet.add(A[i]);<br>          break;<br>       &#125;<br>    &#125;<br> &#125;<br></code></pre></div></td></tr></table></figure>

<p>数据库最费劲的就是跟程序链接释放。假设链接了两次，每次做上百万次的数据集查询，查完就走，这样就只做了两次；相反建立了上百万次链接，申请链接释放反复重复，这样系统就受不了了。即mysql优化原则，就是小表驱动大表，小的数据集驱动大的数据集，从而让性能更优。</p>
<p>因此，我们要选择最外层循环小的，也就是，如果<strong>B的数据量小于A，适合使用in，如果B的数据量大于A，即适合选择exist</strong>。</p>
<h3 id="21、尽量用-union-all-替换-union"><a href="#21、尽量用-union-all-替换-union" class="headerlink" title="21、尽量用 union all 替换 union"></a>21、尽量用 union all 替换 union</h3><p>如果检索结果中不会有重复的记录，推荐union all 替换 union。</p>
<p>反例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid<span class="hljs-operator">=</span><span class="hljs-number">1</span><br><span class="hljs-keyword">union</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure>

<p>正例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid<span class="hljs-operator">=</span><span class="hljs-number">1</span><br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br></code></pre></div></td></tr></table></figure>

<p>理由：</p>
<ul>
<li>如果使用union，不管检索结果有没有重复，都会尝试进行合并，然后在输出最终结果前进行排序。如果已知检索结果没有重复记录，使用union all 代替union，这样会提高效率。</li>
</ul>
<h3 id="22、索引不宜太多，一般5个以内。"><a href="#22、索引不宜太多，一般5个以内。" class="headerlink" title="22、索引不宜太多，一般5个以内。"></a>22、索引不宜太多，一般5个以内。</h3><ul>
<li>索引并不是越多越好，索引虽然提高了查询的效率，但是也降低了插入和更新的效率。</li>
<li>insert或update时有可能会重建索引，所以建索引需要慎重考虑，视具体情况来定。</li>
<li>一个表的索引数最好不要超过5个，若太多需要考虑一些索引是否没有存在的必要。</li>
</ul>
<h3 id="23、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型"><a href="#23、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型" class="headerlink" title="23、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型"></a>23、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型</h3><p>反例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">king_id` <span class="hljs-type">varchar</span>（<span class="hljs-number">20</span>） <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;守护者Id&#x27;</span><br></code></pre></div></td></tr></table></figure>

<p>正例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">`king_id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;守护者Id&#x27;</span>`<br></code></pre></div></td></tr></table></figure>

<p>理由：</p>
<ul>
<li>相对于数字型字段，字符型会降低查询和连接的性能，并会增加存储开销。</li>
</ul>
<h3 id="24、索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段。"><a href="#24、索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段。" class="headerlink" title="24、索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段。"></a>24、索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段。</h3><p>因为SQL优化器是根据表中数据量来进行查询优化的，如果索引列有大量重复数据，Mysql查询优化器推算发现不走索引的成本更低，很可能就放弃索引了。</p>
<h3 id="25、尽量避免向客户端返回过多数据量。"><a href="#25、尽量避免向客户端返回过多数据量。" class="headerlink" title="25、尽量避免向客户端返回过多数据量。"></a>25、尽量避免向客户端返回过多数据量。</h3><p>假设业务需求是，用户请求查看自己最近一年观看过的直播数据。</p>
<p>反例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>一次性查询所有数据回来<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> LivingInfo <span class="hljs-keyword">where</span> watchId <span class="hljs-operator">=</span> useId <span class="hljs-keyword">and</span> watchTime <span class="hljs-operator">&gt;=</span> Date_sub(now(), <span class="hljs-type">Interval</span> <span class="hljs-number">1</span> Y)<br></code></pre></div></td></tr></table></figure>

<p>正例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>分页查询<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> LivingInfo <span class="hljs-keyword">where</span> watchId <span class="hljs-operator">=</span> useId <span class="hljs-keyword">and</span> watchTime <span class="hljs-operator">&gt;=</span> Date_sub(now(),<span class="hljs-type">Interval</span> <span class="hljs-number">1</span> Y) limit <span class="hljs-keyword">offset</span>, pageSize<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>如果是前端分页，可以先查询前两百条记录，因为一般用户应该也不会往下翻太多页，<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> LivingInfo <span class="hljs-keyword">where</span> watchId <span class="hljs-operator">=</span> useId <span class="hljs-keyword">and</span> watchTime <span class="hljs-operator">&gt;=</span> Date_sub(now(), <span class="hljs-type">Interval</span> <span class="hljs-number">1</span> Y) limit <span class="hljs-number">200</span> ;<br></code></pre></div></td></tr></table></figure>

<h3 id="26、当在SQL语句中连接多个表时-请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰。"><a href="#26、当在SQL语句中连接多个表时-请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰。" class="headerlink" title="26、当在SQL语句中连接多个表时,请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰。"></a>26、当在SQL语句中连接多个表时,请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰。</h3><p>反例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">inner</span><br><span class="hljs-keyword">join</span> B <span class="hljs-keyword">on</span> A.deptId <span class="hljs-operator">=</span> B.deptId;<br></code></pre></div></td></tr></table></figure>

<p>正例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  memeber.name, deptment.deptName <span class="hljs-keyword">from</span> A <span class="hljs-keyword">member</span> <span class="hljs-keyword">inner</span><br><span class="hljs-keyword">join</span> B deptment <span class="hljs-keyword">on</span> member.deptId <span class="hljs-operator">=</span> deptment.deptId;<br></code></pre></div></td></tr></table></figure>

<h3 id="27、尽可能使用varchar-nvarchar-代替-char-nchar。"><a href="#27、尽可能使用varchar-nvarchar-代替-char-nchar。" class="headerlink" title="27、尽可能使用varchar/nvarchar 代替 char/nchar。"></a>27、尽可能使用varchar/nvarchar 代替 char/nchar。</h3><p>反例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">`deptName` <span class="hljs-type">char</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;部门名称&#x27;</span><br></code></pre></div></td></tr></table></figure>

<p>正例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">`deptName` <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;部门名称&#x27;</span><br></code></pre></div></td></tr></table></figure>

<p>理由：</p>
<ul>
<li>因为首先变长字段存储空间小，可以节省存储空间。</li>
<li>其次对于查询来说，在一个相对较小的字段内搜索，效率更高。</li>
</ul>
<h3 id="28、为了提高group-by-语句的效率，可以在执行到该语句前，把不需要的记录过滤掉。"><a href="#28、为了提高group-by-语句的效率，可以在执行到该语句前，把不需要的记录过滤掉。" class="headerlink" title="28、为了提高group by 语句的效率，可以在执行到该语句前，把不需要的记录过滤掉。"></a>28、为了提高group by 语句的效率，可以在执行到该语句前，把不需要的记录过滤掉。</h3><p>反例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> job, <span class="hljs-built_in">avg</span>(salary) <span class="hljs-keyword">from</span> employee  <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> job <span class="hljs-keyword">having</span> job <span class="hljs-operator">=</span><span class="hljs-string">&#x27;president&#x27;</span><br><span class="hljs-keyword">or</span> job <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;managent&#x27;</span><br></code></pre></div></td></tr></table></figure>

<p>正例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> job, <span class="hljs-built_in">avg</span>(salary) <span class="hljs-keyword">from</span> employee <span class="hljs-keyword">where</span> job <span class="hljs-operator">=</span><span class="hljs-string">&#x27;president&#x27;</span><br><span class="hljs-keyword">or</span> job <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;managent&#x27;</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> job；<br></code></pre></div></td></tr></table></figure>

<h3 id="29、如何字段类型是字符串，where时一定用引号括起来，否则索引失效"><a href="#29、如何字段类型是字符串，where时一定用引号括起来，否则索引失效" class="headerlink" title="29、如何字段类型是字符串，where时一定用引号括起来，否则索引失效"></a>29、如何字段类型是字符串，where时一定用引号括起来，否则索引失效</h3><p>反例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br></code></pre></div></td></tr></table></figure>

<p><img src="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131709846.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p>正例：</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid <span class="hljs-operator">=</span><span class="hljs-string">&#x27;123&#x27;</span>;<br></code></pre></div></td></tr></table></figure>

<p><img src="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131709592.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p>理由：</p>
<ul>
<li>为什么第一条语句未加单引号就不走索引了呢？这是因为不加单引号时，是字符串跟数字的比较，它们类型不匹配，MySQL会做隐式的类型转换，把它们转换为浮点数再做比较。</li>
</ul>
<h3 id="30、使用explain-分析你SQL的计划"><a href="#30、使用explain-分析你SQL的计划" class="headerlink" title="30、使用explain 分析你SQL的计划"></a>30、使用explain 分析你SQL的计划</h3><p>日常开发写SQL的时候，尽量养成一个习惯吧。用explain分析一下你写的SQL，尤其是走不走索引这一块。</p>
<figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> userid <span class="hljs-operator">=</span> <span class="hljs-number">10086</span> <span class="hljs-keyword">or</span> age <span class="hljs-operator">=</span> <span class="hljs-number">18</span>;<br></code></pre></div></td></tr></table></figure>

<p><img src="https://tuyong.oss-cn-hangzhou.aliyuncs.com/img/202203131709024.png" srcset="/img/loading.gif" lazyload alt="图片"></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Database/">Database</a>
                    
                      <a class="hover-with-bg" href="/categories/Database/MySQL/">MySQL</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
                    
                      <a class="hover-with-bg" href="/tags/MySQL/">MySQL</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/03/25/%E6%A2%B3%E7%90%86%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%20MQ%20JMS%20Kafka/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">梳理消息队列 MQ/JMS/Kafka</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/03/25/%E6%89%8B%E6%92%B8%E4%BA%86%E4%B8%80%E4%B8%AA%20Spring%20MVC%20%E6%A1%86%E6%9E%B6/">
                        <span class="hidden-mobile">手撸了一个 Spring MVC 框架</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://github.com/xiaobeibi" target="_blank" rel="nofollow noopener"><span>Github</span></a> <i class="iconfont icon-love"></i> <a href="https://gitee.com/tytokongjian" target="_blank" rel="nofollow noopener"><span>Gitee</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
