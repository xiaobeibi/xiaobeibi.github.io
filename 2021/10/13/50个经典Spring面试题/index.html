

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon_ico.png">
  <link rel="icon" href="/img/favicon_ico.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="分享总结个人的学习路程">
  <meta name="author" content="屠雍">
  <meta name="keywords" content="PCB, 单片机, 物联网, 嵌入式, Java, Linux, Web前端">
  <meta name="description" content="50 个 经典 Spring 面试题  1、基础概念1.1. 不同版本的 Spring Framework 有哪些主要功能？  1.2. 什么是 Spring Framework？ Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。 它是轻量级、松散耦合的。 它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。 它可以集成其他框架，如 St">
<meta property="og:type" content="article">
<meta property="og:title" content="50 个 经典 Spring 面试题">
<meta property="og:url" content="http://example.com/2021/10/13/50%E4%B8%AA%E7%BB%8F%E5%85%B8Spring%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="小贝比">
<meta property="og:description" content="50 个 经典 Spring 面试题  1、基础概念1.1. 不同版本的 Spring Framework 有哪些主要功能？  1.2. 什么是 Spring Framework？ Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。 它是轻量级、松散耦合的。 它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。 它可以集成其他框架，如 St">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/tytokongjian/image/raw/master/images/20210501103637.png">
<meta property="og:image" content="https://gitee.com/tytokongjian/image/raw/master/images/20210501103744.webp">
<meta property="og:image" content="https://gitee.com/tytokongjian/image/raw/master/images/20210501103807.png">
<meta property="og:image" content="https://gitee.com/tytokongjian/image/raw/master/images/20210501104003.webp">
<meta property="og:image" content="https://gitee.com/tytokongjian/image/raw/master/images/20210501104025.webp">
<meta property="og:image" content="https://gitee.com/tytokongjian/image/raw/master/images/20210501104239.webp">
<meta property="og:image" content="https://gitee.com/tytokongjian/image/raw/master/images/20210501104422.webp">
<meta property="og:image" content="https://gitee.com/tytokongjian/image/raw/master/images/20210501104452.png">
<meta property="og:image" content="https://gitee.com/tytokongjian/image/raw/master/images/20210501104553.png">
<meta property="og:image" content="https://gitee.com/tytokongjian/image/raw/master/images/20210501104624.png">
<meta property="article:published_time" content="2021-10-13T14:16:43.220Z">
<meta property="article:modified_time" content="2021-10-13T10:24:56.543Z">
<meta property="article:author" content="屠雍">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://gitee.com/tytokongjian/image/raw/master/images/20210501103637.png">
  
  <title>50 个 经典 Spring 面试题 - 小贝比</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/atom-one-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>小贝比的个人博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/background7.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="50 个 经典 Spring 面试题">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-10-13 22:16" pubdate>
        2021年10月13日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      12k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      37 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">50 个 经典 Spring 面试题</h1>
            
            <div class="markdown-body">
              <center><h2>50 个 经典 Spring 面试题</h2></center>

<h3 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a><strong>1、基础概念</strong></h3><p><strong>1.1. 不同版本的 Spring Framework 有哪些主要功能？</strong></p>
<p><img src="https://gitee.com/tytokongjian/image/raw/master/images/20210501103637.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p><strong>1.2. 什么是 Spring Framework？</strong></p>
<p>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</p>
<p>它是轻量级、松散耦合的。</p>
<p>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。</p>
<p>它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。</p>
<p>本篇是 Spring 框架面试题，关于 Spring 实战可以关注公众号「Java后端」回复 666 下载~</p>
<p><strong>1.3. 列举 Spring Framework 的优点。</strong></p>
<p>由于 Spring Frameworks 的分层架构，用户可以自由选择自己需要的组件。</p>
<p>Spring Framework 支持 POJO(Plain Old Java Object) 编程，从而具备持续集成和可测试性。</p>
<p>由于依赖注入和控制反转，JDBC 得以简化。</p>
<p>它是开源免费的。</p>
<p><strong>1.4. Spring Framework 有哪些不同的功能？</strong></p>
<p>轻量级 - Spring 在代码量和透明度方面都很轻便。</p>
<p>IOC - 控制反转</p>
<p>AOP - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。</p>
<p>容器 - Spring 负责创建和管理对象（Bean）的生命周期和配置。</p>
<p>MVC - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。</p>
<p>事务管理 - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。</p>
<p>JDBC 异常 - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</p>
<p><strong>1.5. Spring Framework 中有多少个模块，它们分别是什么？</strong></p>
<p><img src="https://gitee.com/tytokongjian/image/raw/master/images/20210501103744.webp" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p>Spring 核心容器 – 该层基本上是 Spring Framework 的核心。它包含以下模块：</p>
<ul>
<li>Spring Core</li>
<li>Spring Bean</li>
<li>SpEL (Spring Expression Language)</li>
<li>Spring Context</li>
</ul>
<p>数据访问/集成 – 该层提供与数据库交互的支持。它包含以下模块：</p>
<ul>
<li>JDBC (Java DataBase Connectivity)</li>
<li>ORM (Object Relational Mapping)</li>
<li>OXM (Object XML Mappers)</li>
<li>JMS (Java Messaging Service)</li>
<li>Transaction</li>
</ul>
<p>Web – 该层提供了创建 Web 应用程序的支持。它包含以下模块：</p>
<ul>
<li>Web</li>
<li>Web – Servlet</li>
<li>Web – Socket</li>
<li>Web – Portlet</li>
</ul>
<p><strong>AOP</strong> – 该层支持面向切面编程</p>
<p><strong>Instrumentation</strong> – 该层为类检测和类加载器实现提供支持。</p>
<p><strong>Test</strong> – 该层为使用 JUnit 和 TestNG 进行测试提供支持。</p>
<p>几个杂项模块:</p>
<ul>
<li>Messaging – 该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息</li>
<li>Aspects – 该模块为与 AspectJ 的集成提供支持。</li>
</ul>
<p><strong>1.6. 什么是 Spring 配置文件？</strong></p>
<p>Spring 配置文件是 XML 文件。该文件主要包含类信息。它描述了这些类是如何配置以及相互引入的。但是，XML 配置文件冗长且更加干净。如果没有正确规划和编写，那么在大项目中管理变得非常困难。</p>
<p><strong>1.7. Spring 应用程序有哪些不同组件？</strong></p>
<p>Spring 应用一般有以下组件：</p>
<p><strong>接口</strong> - 定义功能。</p>
<p><strong>Bean 类</strong> - 它包含属性，setter 和 getter 方法，函数等。</p>
<p><strong>Spring 面向切面编程（AOP）</strong> - 提供面向切面编程的功能。</p>
<p><strong>Bean 配置文件</strong> - 包含类的信息以及如何配置它们。</p>
<p><strong>用户程序</strong> - 它使用接口。</p>
<p><strong>1.8. 使用 Spring 有哪些方式？</strong></p>
<p>使用 Spring 有以下方式：</p>
<ul>
<li>作为一个成熟的 Spring Web 应用程序。</li>
<li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。</li>
<li>用于远程使用。</li>
<li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。</li>
</ul>
<h3 id="2、依赖注入（Ioc）"><a href="#2、依赖注入（Ioc）" class="headerlink" title="2、依赖注入（Ioc）"></a><strong>2、依赖注入（Ioc）</strong></h3><p><strong>2.1. 什么是 Spring IOC 容器？</strong></p>
<p>Spring 框架的核心是 Spring 容器。容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期。Spring 容器使用依赖注入来管理组成应用程序的组件。</p>
<p>容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令。该元数据可以通过 XML，Java 注解或 Java 代码提供。</p>
<p><img src="https://gitee.com/tytokongjian/image/raw/master/images/20210501103807.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p><strong>2.2. 什么是依赖注入？</strong></p>
<p>在依赖注入中，您不必创建对象，但必须描述如何创建它们。您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。由 IoC 容器将它们装配在一起。</p>
<p><strong>2.3. 可以通过多少种方式完成依赖注入？</strong></p>
<p>通常，依赖注入可以通过三种方式完成，即：</p>
<ul>
<li>构造函数注入</li>
<li>setter 注入</li>
<li>接口注入</li>
</ul>
<p>在 Spring Framework 中，仅使用构造函数和 setter 注入。</p>
<p><strong>2.4. 区分构造函数注入和 setter 注入。</strong></p>
<p><img src="https://gitee.com/tytokongjian/image/raw/master/images/20210501104003.webp" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p><strong>2.5. spring 中有多少种 IOC 容器？</strong></p>
<ul>
<li>BeanFactory - BeanFactory 就像一个包含 bean 集合的工厂类。它会在客户端要求时实例化 bean。</li>
<li>ApplicationContext - ApplicationContext 接口扩展了 BeanFactory 接口。它在 BeanFactory 基础上提供了一些额外的功能。</li>
</ul>
<p><strong>2.6. 区分 BeanFactory 和 ApplicationContext。</strong></p>
<p><img src="https://gitee.com/tytokongjian/image/raw/master/images/20210501104025.webp" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p><strong>2.7. 列举 IoC 的一些好处。</strong></p>
<p>IoC 的一些好处是：</p>
<ul>
<li>它将最小化应用程序中的代码量。</li>
<li>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</li>
<li>它以最小的影响和最少的侵入机制促进松耦合。</li>
<li>它支持即时的实例化和延迟加载服务。</li>
</ul>
<p><strong>2.8. Spring IoC 的实现机制。</strong></p>
<p>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Fruit</span> </span>&#123;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Fruit</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Apple&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Orange</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Fruit</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Orange&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Fruit <span class="hljs-title">getInstance</span><span class="hljs-params">(String ClassName)</span> </span>&#123;<br>        Fruit f=<span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            f=(Fruit)Class.forName(ClassName).newInstance();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> f;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] a)</span> </span>&#123;<br>        Fruit f=Factory.getInstance(<span class="hljs-string">&quot;io.github.dunwu.spring.Apple&quot;</span>);<br>        <span class="hljs-keyword">if</span>(f!=<span class="hljs-keyword">null</span>)&#123;<br>            f.eat();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="3、Beans"><a href="#3、Beans" class="headerlink" title="3、Beans"></a><strong>3、Beans</strong></h3><p><strong>3.1. 什么是 spring bean？</strong></p>
<ul>
<li>它们是构成用户应用程序主干的对象。</li>
<li>Bean 由 Spring IoC 容器管理。</li>
<li>它们由 Spring IoC 容器实例化，配置，装配和管理。</li>
<li>Bean 是基于用户提供给容器的配置元数据创建。</li>
</ul>
<p><strong>3.2. spring 提供了哪些配置方式？</strong></p>
<ul>
<li><strong>基于 xml 配置</strong></li>
</ul>
<p>bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentbean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.edureka.firstSpring.StudentBean&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Edureka&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<ul>
<li><strong>基于注解配置</strong></li>
</ul>
<p>您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- bean definitions go here --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<ul>
<li><strong>基于 Java API 配置</strong></li>
</ul>
<p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p>
<ol>
<li>@Bean 注解扮演与 <bean /> 元素相同的角色。</li>
<li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li>
</ol>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> StudentBean <span class="hljs-title">myStudent</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StudentBean();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>3.3. spring 支持集中 bean scope？</strong></p>
<p>Spring bean 支持 5 种 scope：</p>
<ul>
<li>Singleton - 每个 Spring IoC 容器仅有一个单实例。</li>
<li>Prototype - 每次请求都会产生一个新的实例。</li>
<li>Request - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。</li>
<li>Session - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。</li>
<li>Global-session - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。</li>
</ul>
<p>仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。更多spring内容</p>
<p><strong>3.4. spring bean 容器的生命周期是什么样的？</strong></p>
<p>spring bean 容器的生命周期流程如下：</p>
<ol>
<li>Spring 容器根据配置中的 bean 定义中实例化 bean</li>
<li>Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。</li>
<li>如果 bean 实现 BeanNameAware 接口，则工厂通过传递 bean 的 ID 来调用 setBeanName()。</li>
<li>如果 bean 实现 BeanFactoryAware 接口，工厂通过传递自身的实例来调用 setBeanFactory()。</li>
<li>如果存在与 bean 关联的任何 BeanPostProcessors，则调用 preProcessBeforeInitialization() 方法。</li>
<li>如果为 bean 指定了 init 方法（ <bean>的 init-method 属性），那么将调用它。</li>
<li>最后，如果存在与 bean 关联的任何 BeanPostProcessors，则将调用 postProcessAfterInitialization() 方法。</li>
<li>如果 bean 实现 DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。</li>
<li>如果为 bean 指定了 destroy 方法（ <bean>的 destroy-method 属性），那么将调用它。</li>
</ol>
<p><img src="https://gitee.com/tytokongjian/image/raw/master/images/20210501104239.webp" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p><strong>3.5. 什么是 spring 的内部 bean？</strong></p>
<p>只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean。为了定义 bean，Spring 的基于 XML 的配置元数据在<property>或<constructor-arg> 中提供了<bean>元素的使用。内部 bean 总是匿名的，它们总是作为原型。</p>
<p>例如，假设我们有一个 Student 类，其中引用了 Person 类。这里我们将只创建一个 Person 类实例并在 Student 中使用它。</p>
<p>Student.java</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Person person;<br>    <span class="hljs-comment">//Setters and Getters</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String address;<br>    <span class="hljs-comment">//Setters and Getters</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>bean.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">“StudentBean</span>&quot; <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.edureka.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;person&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--This is inner bean --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.edureka.Person&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">“Scott</span>&quot;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">“Bangalore</span>&quot;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p><strong>3.6. 什么是 spring 装配</strong></p>
<p>当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配。Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。</p>
<p><strong>3.7. 自动装配有哪些方式？</strong></p>
<p>Spring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。</p>
<p>自动装配的不同模式：</p>
<ul>
<li>no - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。</li>
<li>byName - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。</li>
<li>byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。</li>
<li>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li>
<li>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li>
</ul>
<p><strong>3.8. 自动装配有什么局限？</strong></p>
<ul>
<li>覆盖的可能性 - 您始终可以使用<constructor-arg> 和 <property>设置指定依赖项，这将覆盖自动装配。</li>
<li>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。</li>
<li>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。</li>
</ul>
<h3 id="4、注-解"><a href="#4、注-解" class="headerlink" title="4、注 解"></a><strong>4、注 解</strong></h3><p><strong>4.1. 你用过哪些重要的 Spring 注解？</strong></p>
<ul>
<li>@Controller - 用于 Spring MVC 项目中的控制器类。</li>
<li>@Service - 用于服务类。</li>
<li>@RequestMapping - 用于在控制器处理程序方法中配置 URI 映射。</li>
<li>@ResponseBody - 用于发送 Object 作为响应，通常用于发送 XML 或 JSON 数据作为响应。</li>
<li>@PathVariable - 用于将动态值从 URI 映射到处理程序方法参数。</li>
<li>@Autowired - 用于在 spring bean 中自动装配依赖项。</li>
<li>@Qualifier - 使用 @Autowired 注解，以避免在存在多个 bean 类型实例时出现混淆。</li>
<li>@Scope - 用于配置 spring bean 的范围。</li>
<li>@Configuration，@ComponentScan 和 @Bean - 用于基于 java 的配置。</li>
<li>@Aspect，@Before，@After，@Around，@Pointcut - 用于切面编程（AOP）。</li>
</ul>
<p><strong>4.2. 如何在 spring 中启动注解装配？</strong></p>
<p>默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置&lt;context：annotation-config /&gt; 元素在 Spring 配置文件中启用它。</p>
<p><strong>4.3. @Component, @Controller, @Repository, @Service 有何区别？</strong></p>
<ul>
<li>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</li>
<li>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</li>
<li>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</li>
<li>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</li>
</ul>
<p><strong>4.4. @Required 注解有什么用？</strong></p>
<p>@Required 应用于 bean 属性 setter 方法。此注解仅指示必须在配置时使用 bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性。如果尚未填充受影响的 bean 属性，则容器将抛出 BeanInitializationException。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Required</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> string <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>4.5. @Autowired 注解有什么用？</strong></p>
<p>@Autowired 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 bean。默认情况下，它是类型驱动的注入。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> string <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>4.6. @Qualifier 注解有什么用？</strong></p>
<p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</p>
<p>例如，这里我们分别有两个类，Employee 和 EmpAccount。在 EmpAccount 中，使用@Qualifier 指定了必须装配 id 为 emp1 的 bean。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> string <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>EmpAccount.java</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmpAccount</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Employee emp;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(emp1)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showName</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(“Employee name : ”+emp.getName);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>4.7. @RequestMapping 注解有什么用？</strong></p>
<p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。此注解可应用于两个级别：</p>
<ul>
<li>类级别：映射请求的 URL</li>
<li>方法级别：映射 URL 以及 HTTP 请求方法</li>
</ul>
<h3 id="5、数据访问"><a href="#5、数据访问" class="headerlink" title="5、数据访问"></a><strong>5、数据访问</strong></h3><p><strong>5.1. spring DAO 有什么用？</strong></p>
<p>Spring DAO 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</p>
<p><strong>5.2. 列举 Spring DAO 抛出的异常。</strong></p>
<p><img src="https://gitee.com/tytokongjian/image/raw/master/images/20210501104422.webp" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p><strong>5.3. spring JDBC API 中存在哪些类？</strong></p>
<ul>
<li>JdbcTemplate</li>
<li>SimpleJdbcTemplate</li>
<li>NamedParameterJdbcTemplate</li>
<li>SimpleJdbcInsert</li>
<li>SimpleJdbcCall</li>
</ul>
<p><strong>5.4. 使用 Spring 访问 Hibernate 的方法有哪些？</strong></p>
<p>我们可以通过两种方式使用 Spring 访问 Hibernate：</p>
<ol>
<li>使用 Hibernate 模板和回调进行控制反转</li>
<li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</li>
</ol>
<p><strong>5.5. 列举 spring 支持的事务管理类型</strong></p>
<p>Spring 支持两种类型的事务管理：</p>
<ol>
<li>程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。</li>
<li>声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML 的配置来管理事务。</li>
</ol>
<p><strong>5.6. Spring 支持哪些 ORM 框架</strong></p>
<ul>
<li>Hibernate</li>
<li>iBatis</li>
<li>JPA</li>
<li>JDO</li>
<li>OJB</li>
</ul>
<h3 id="6、AOP"><a href="#6、AOP" class="headerlink" title="6、AOP"></a><strong>6、AOP</strong></h3><p><strong>6.1. 什么是 AOP？</strong></p>
<p>AOP(Aspect-Oriented Programming), 即 面向切面编程, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角.</p>
<p>在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 Aspect(切面)</p>
<p><strong>6.2. AOP 中的 Aspect、Advice、Pointcut、JointPoint 和 Advice 参数分别是什么？</strong></p>
<p><img src="https://gitee.com/tytokongjian/image/raw/master/images/20210501104452.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<ol>
<li>Aspect - Aspect 是一个实现交叉问题的类，例如事务管理。方面可以是配置的普通类，然后在 Spring Bean 配置文件中配置，或者我们可以使用 Spring AspectJ 支持使用 @Aspect 注解将类声明为 Aspect。</li>
<li>Advice - Advice 是针对特定 JoinPoint 采取的操作。在编程方面，它们是在应用程序中达到具有匹配切入点的特定 JoinPoint 时执行的方法。您可以将 Advice 视为 Spring 拦截器（Interceptor）或 Servlet 过滤器（filter）。</li>
<li>Advice Arguments - 我们可以在 advice 方法中传递参数。我们可以在切入点中使用 args() 表达式来应用于与参数模式匹配的任何方法。如果我们使用它，那么我们需要在确定参数类型的 advice 方法中使用相同的名称。</li>
<li>Pointcut - Pointcut 是与 JoinPoint 匹配的正则表达式，用于确定是否需要执行 Advice。Pointcut 使用与 JoinPoint 匹配的不同类型的表达式。Spring 框架使用 AspectJ Pointcut 表达式语言来确定将应用通知方法的 JoinPoint。</li>
<li>JoinPoint - JoinPoint 是应用程序中的特定点，例如方法执行，异常处理，更改对象变量值等。在 Spring AOP 中，JoinPoint 始终是方法的执行器。</li>
</ol>
<p><strong>6.3. 什么是通知（Advice）？</strong></p>
<p>特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice。Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的拦截器。</p>
<p><strong>6.4. 有哪些类型的通知（Advice）？</strong></p>
<ul>
<li>Before - 这些类型的 Advice 在 joinpoint 方法之前执行，并使用 @Before 注解标记进行配置。</li>
<li>After Returning - 这些类型的 Advice 在连接点方法正常执行后执行，并使用@AfterReturning 注解标记进行配置。</li>
<li>After Throwing - 这些类型的 Advice 仅在 joinpoint 方法通过抛出异常退出并使用 @AfterThrowing 注解标记配置时执行。</li>
<li>After (finally) - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 @After 注解标记进行配置。</li>
<li>Around - 这些类型的 Advice 在连接点之前和之后执行，并使用 @Around 注解标记进行配置。</li>
</ul>
<p><strong>6.5. 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。</strong></p>
<p>concern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。</p>
<p>cross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。</p>
<p><strong>6.6. AOP 有哪些实现方式？</strong></p>
<p>实现 AOP 的技术，主要分为两大类：</p>
<ul>
<li>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；</li>
<li>编译时编织（特殊编译器实现）</li>
<li>类加载时编织（特殊的类加载器实现）。</li>
<li>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</li>
<li>JDK 动态代理</li>
<li>CGLIB</li>
</ul>
<p><strong>6.7. Spring AOP and AspectJ AOP 有什么区别？</strong></p>
<p>Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。</p>
<p>Spring AOP 仅支持方法级别的 PointCut；提供了完全的 AOP 支持，它还支持属性级别的 PointCut。</p>
<p><strong>6.8. 如何理解 Spring 中的代理？</strong></p>
<p>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。</p>
<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Advice + Target Object = Proxy<br></code></pre></div></td></tr></table></figure>

<p><strong>6.9. 什么是编织（Weaving）？</strong></p>
<p>为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（Weaving）。在 Spring AOP 中，编织在运行时执行。请参考下图：</p>
<p><img src="https://gitee.com/tytokongjian/image/raw/master/images/20210501104553.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<h3 id="7、MVC"><a href="#7、MVC" class="headerlink" title="7、MVC"></a><strong>7、MVC</strong></h3><p><strong>7.1. Spring MVC 框架有什么用？</strong></p>
<p>Spring Web MVC 框架提供 模型-视图-控制器 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。</p>
<p><strong>7.2. 描述一下 DispatcherServlet 的工作流程</strong></p>
<p>DispatcherServlet 的工作流程可以用一幅图来说明：</p>
<p><img src="https://gitee.com/tytokongjian/image/raw/master/images/20210501104624.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<ol>
<li>向服务器发送 HTTP 请求，请求被前端控制器 DispatcherServlet 捕获。</li>
<li>DispatcherServlet 根据 -servlet.xml 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以HandlerExecutionChain 对象的形式返回。</li>
<li>DispatcherServlet 根据获得的Handler，选择一个合适的 HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的 preHandler(…)方法）。</li>
<li>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。在填充Handler的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：</li>
</ol>
<ul>
<li>HttpMessageConveter：将请求消息（如 Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。</li>
<li>数据转换：对请求消息进行数据转换。如<code>String</code>转换成<code>Integer</code>、<code>Double</code>等。</li>
<li>数据根式化：对请求消息进行数据格式化。如将字符串转换成格式化数字或格式化日期等。</li>
<li>数据验证：验证数据的有效性（长度、格式等），验证结果存储到<code>BindingResult</code>或<code>Error</code>中。</li>
</ul>
<ol start="5">
<li><p>Handler(Controller)执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象；</p>
</li>
<li><p>根据返回的ModelAndView，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的ViewResolver)返回给DispatcherServlet。</p>
</li>
<li><p>ViewResolver 结合Model和View，来渲染视图。</p>
</li>
<li><p>视图负责将渲染结果返回给客户端。</p>
</li>
</ol>
<p><strong>7.3. 介绍一下 WebApplicationContext</strong></p>
<p>WebApplicationContext 是 ApplicationContext 的扩展。它具有 Web 应用程序所需的一些额外功能。它与普通的 ApplicationContext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/categories/Java/Spring/">Spring</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                      <a class="hover-with-bg" href="/tags/Spring/">Spring</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/10/13/%E6%89%B9%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6%20Spring%20Batch%20%E8%AF%A6%E8%A7%A3/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">批处理框架 Spring Batch 详解</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/10/13/10%20%E4%B8%AA%20Spring%20%E9%94%99%E8%AF%AF/">
                        <span class="hidden-mobile">10 个 Spring 错误</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://github.com/xiaobeibi" target="_blank" rel="nofollow noopener"><span>Github</span></a> <i class="iconfont icon-love"></i> <a href="https://gitee.com/tytokongjian" target="_blank" rel="nofollow noopener"><span>Gitee</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
